// SpectroFX com espectrograma

#pragma once
#include "rack.hpp"
using namespace rack;

struct SpectroFXModule : Module {
    enum ParamIds {
        NUM_PARAMS
    };
    enum InputIds {
        AUDIO_INPUT,
        NUM_INPUTS
    };
    enum OutputIds {
        AUDIO_OUTPUT,
        NUM_OUTPUTS
    };
    enum LightIds {
        NUM_LIGHTS
    };

    dsp::FFT fft;
    std::vector<float> inputBuffer;
    int bufferIndex = 0;

    SpectroFXModule() : fft(9) { // 2^9 = 512 pontos FFT
        config(NUM_PARAMS, NUM_INPUTS, NUM_OUTPUTS, NUM_LIGHTS);
        inputBuffer.resize(512, 0.0f);
    }

    void process(const ProcessArgs& args) override {
        float in = inputs[AUDIO_INPUT].getVoltage();
        outputs[AUDIO_OUTPUT].setVoltage(in);

        // Armazena no buffer circular
        inputBuffer[bufferIndex] = in;
        bufferIndex = (bufferIndex + 1) % 512;
    }
};

// Widget para o espectrograma
struct SpectrogramDisplay : Widget {
    SpectroFXModule* module;

    SpectrogramDisplay(SpectroFXModule* module) {
        this->module = module;
        box.setPos(Vec(0, 0));
        box.setSize(Vec(40.64, 60)); // tamanho em mm
    }

    void draw(const DrawArgs& args) override {
        if (!module)
            return;

        // Copia dados e faz FFT
        float buffer[512];
        for (int i = 0; i < 512; i++)
            buffer[i] = module->inputBuffer[(module->bufferIndex + i) % 512];

        dsp::RealFFT realFft(9); // 2^9 = 512
        realFft.forward(buffer);

        nvgBeginPath(args.vg);
        nvgMoveTo(args.vg, 0, box.size.y);

        for (int i = 0; i < 256; i++) { // metade da FFT (real)
            float mag = std::sqrt(buffer[2 * i] * buffer[2 * i] + buffer[2 * i + 1] * buffer[2 * i + 1]);
            mag = std::log(mag + 1e-6f) * 10.0f; // escala log para melhor visualização

            float x = (float)i / 255.0f * box.size.x;
            float y = box.size.y - clamp(mag * 3.0f, 0.0f, box.size.y);
            nvgLineTo(args.vg, x, y);
        }

        nvgLineTo(args.vg, box.size.x, box.size.y);
        nvgClosePath(args.vg);
        nvgFillColor(args.vg, nvgRGB(50, 200, 255));
        nvgFill(args.vg);
    }
};

// SpectroFXModule.cpp
#include "SpectroFXModule.hpp"
#include "plugin.hpp"

struct SpectroFXModuleWidget : ModuleWidget {
    SpectroFXModuleWidget(SpectroFXModule* module) {
        setModule(module);
        setPanel(APP->window->loadSvg(asset::plugin(pluginInstance, "res/SpectroFXModule.svg")));

        addInput(createInputCentered<PJ301MPort>(mm2px(Vec(10, 30)), module, SpectroFXModule::AUDIO_INPUT));
        addOutput(createOutputCentered<PJ301MPort>(mm2px(Vec(30, 30)), module, SpectroFXModule::AUDIO_OUTPUT));

        SpectrogramDisplay* spectrogram = new SpectrogramDisplay(module);
        spectrogram->box.pos = mm2px(Vec(0, 50));
        spectrogram->box.size = mm2px(Vec(40.64, 60));
        addChild(spectrogram);
    }
};

Model* modelSpectroFXModule = createModel<SpectroFXModule, SpectroFXModuleWidget>("SpectroFXModule");
